{"name":"rest-tutorial","tagline":"Instructions for REST with Spring Boot session - Manchester Java Community April 2015","body":"This tutorial introduces Spring Boot to build a rest server and a client for that interface.\r\n\r\nWe're going to build a small sample application using Spring Boot. The application is for a leisure centre that wants to be able to show everyone the classes it offers and let its staff edit those classes\r\n\r\n###Step 1: Set up the project\r\nIn Eclipse, start a new spring starter project:\r\n![](./screenshots/newproject.png)\r\n\r\nSet up details of the project like this - we're using Java 1.8, and Maven to build We're just going to select actuator and web for now, we can add more capabilities later on\r\n![](./screenshots/springstarter.png)\r\n\r\nWe can just click on 'Finish' now, and we will get a zip file downloaded with our new project in. It should look something like this:\r\n![](./screenshots/timetable-step0.png)\r\n\r\nBelieve it or not we can already run this up and it will do things...Launch it in Eclipse\r\n![](./screenshots/run-as-springboot.png)\r\n\r\nNow in a browser navigate to http://localhost:8080/health\r\n\r\nHopefully you'll see something like this:\r\n\r\n![](./screenshots/health-api.png)\r\n\r\nSpring boot actuator has set up a number of URL endpoints automatically. 'health' is one of them. You can see the others when in the console within the IDE (I've shortened the output lines a bit!):\r\n```\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/beans],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/env/{name:.*}],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/env],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/health],methods=[],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/metrics/{name:.*}],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/metrics],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/configprops],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/dump],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/info],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/autoconfig],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/mappings],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/shutdown],methods=[POST],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n... o.s.b.a.e.mvc.EndpointHandlerMapping : Mapped \"{[/trace],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" ...\r\n```\r\nTry out some of the others\r\n\r\n###Step 2: Add a simple REST endpoint\r\nOK. So far so good, let's add some of our own code now.\r\n\r\nFor the REST service, we need two classes, the controller class that tells Spring what function will handle which URL/method and a data model class.\r\n\r\nI'm going to put the data model classes into their own package just to help keep things tidy, so I added timetable.model. Within that package, I created a simple data model class `Event`:\r\n```java\r\npackage timetable.model; \r\n\r\npublic class Event { \r\n    private Long id; \r\n    private String title; \r\n\r\n    public Event(Long id, String title) { \r\n        this.id = id; \r\n        this.title = title; \r\n    } \r\n\r\n    public Long getId() { \r\n        return id; \r\n    } \r\n\r\n    public String getTitle() { \r\n        return title; \r\n    } \r\n\r\n}\r\n```\r\nWe don't need any annotations on this class, or anything else to tell Spring how to handle it\r\n\r\nNow we need a controller class\r\n\r\nFirst of all we'll just add an API to return all events, this will be a GET method call to /timetable and will return a list of Events\r\n\r\nHere's what it looks like (this is in the timetable package)\r\n```java\r\npackage timetable; \r\n\r\nimport java.util.ArrayList; \r\nimport java.util.List; \r\n\r\nimport org.springframework.stereotype.Controller; \r\nimport org.springframework.web.bind.annotation.RequestMapping; \r\nimport org.springframework.web.bind.annotation.RequestMethod; \r\nimport org.springframework.web.bind.annotation.ResponseBody; \r\n\r\nimport timetable.model.Event; \r\n\r\n@Controller \r\n@RequestMapping(\"/timetable\") \r\npublic class TimetableController { \r\n\r\n    @RequestMapping(method=RequestMethod.GET) \r\n    public @ResponseBody List<Event> getEvents(){ \r\n        List<Event> events = new ArrayList<>(); \r\n        events.add(new Event(1L,\"Yoga\")); \r\n        events.add(new Event(2L,\"Boxercise\")); \r\n        return events;         \r\n    } \r\n}\r\n```\r\nThe `@Controller` annotation tells Spring this is a Controller- it's mapping some endpoints.\r\n\r\nThe `@RequestMapping` above the class definition gives the root mapping- so all calls to (in our case) http://localhost:8080/timetable will look in here to be processed\r\n\r\nThe `@RequestMapping` above the `getEvents()` method tells Spring this is the method to use for a GET call, and the `@ResponseBody` annotation before the return type is very important- this tells Spring we want it to send back the body data as it is, we don't have a view defined (the same `RequestMapping` annotations get used for Spring MVC where Spring would expect to find a view class mapped). Miss it off and you'll get an exception when you try to make your API request\r\n\r\nFor now, the body of the method just creates a hard-wired List and returns it\r\n\r\nSave it all and run it back up (Eclipse should autobuild it for you on saving)\r\n\r\nIn the console you should be able to see the new endpoint '/timetable' mapped:\r\n```\r\nMapped \"{[/timetable],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public java.util.List timetable.TimetableController.getEvents()\r\n```\r\nBack in the browser http://localhost:8080/timetable should give you a string of JSON something like this:\r\n```\r\n[{\"id\":1,\"title\":\"Yoga\"},{\"id\":2,\"title\":\"Boxercise\"}]\r\n```\r\n###Step 3: Add in JPA\r\nWe will need implement some methods for the Event resource, these will use the URL http://localhost:8080/timetable/event\r\n\r\nBut before we do that, we will refactor the Event object slightly, so that we use JPA persistence, and we'll extend the object a bit so that it can represent the data a bit better\r\n\r\nWe need to add some dependencies to the pom.xml file inside the `<dependencies>` tag:\r\n```xml\r\n  <dependency> \r\n    <groupId>com.h2database</groupId> \r\n    <artifactId>h2</artifactId> \r\n  </dependency> \r\n  <dependency> \r\n    <groupId>org.springframework.boot</groupId> \r\n    <artifactId>spring-boot-starter-data-jpa</artifactId> \r\n  </dependency>\r\n```\r\nThis gives us the spring data JPA libraries and the h2 in memory database. You could use another database such as MongoDB or MySQL\r\n\r\nNow we'll change `Event`\r\n```java\r\npackage timetable.model;\r\n\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\n\r\n@Entity\r\npublic class Event {\r\n\t@Id\r\n\t@GeneratedValue\r\n\tprivate Long id;\r\n\tprivate String title;\r\n\tprivate Integer day;\r\n\tprivate String startTime;\r\n\tprivate String endTime;\r\n\r\n\tpublic Event() {}\r\n\t\r\n\tpublic Event(String title, Integer day, String startTime, String endTime) {\r\n\t\tthis.title = title;\r\n\t\tthis.day = day;\r\n\t\tthis.startTime = startTime;\r\n\t\tthis.endTime = endTime;\r\n\t}\r\n\r\n\tpublic Long getId() {\r\n\t\treturn id;\r\n\t}\r\n\r\n\tpublic String getTitle() {\r\n\t\treturn title;\r\n\t}\r\n\r\n\tpublic Integer getDay() {\r\n\t\treturn day;\r\n\t}\r\n\t\r\n\tpublic String getStartTime() {\r\n\t\treturn startTime;\r\n\t}\r\n\r\n\tpublic String getEndTime() {\r\n\t\treturn endTime;\r\n\t}\r\n\r\n}\r\n```\r\nWe will need to add a default constructor so that JPA can create the object, and we can remove `id` from the current constructor because the Id is now annotated as auto-generated (`@GeneratedValue`).  I've added in an Integer to represent the day of the week, and two Strings to model the start and end times.\r\n\r\nWe also need to add a repository for our persisted `Event`, we can do this with minimal code just by adding a new interface in the `timetable.model` package:\r\n```java\r\npackage timetable.model; \r\n\r\nimport org.springframework.data.jpa.repository.JpaRepository; \r\n\r\npublic interface EventRepository extends JpaRepository<Event, Long> { \r\n\r\n}\r\n```\r\nWe will need to access the `EventRepository` from the `TimetableController`, so in that class we add a new member:\r\n```java\r\n  @Autowired   EventRepository eventRepo;\r\n```\r\nThen we can change the `TimetableController` `getEvents()` method to use the repository:\r\n```java\r\n    @RequestMapping(method=RequestMethod.GET) \r\n    public @ResponseBody Collection<Event> getEvents(){ \r\n        return eventRepo.findAll(); \r\n         \r\n    }\r\n```\r\nWe can initialise the repository with some default values in the `TimetableApplication` class with this method, which uses a lambda to create a `CommandLineRunner` class that gets run when Spring initialises:\r\n```java\r\n    @Bean\r\n\tCommandLineRunner init(EventRepository eventRepository) {\r\n\t\treturn (evt)-> { \r\n\t\t\teventRepository.save( new Event(\"Yoga\", \r\n\t\t\t\t4,\r\n\t\t\t\t\"8pm\", \"9pm\"));\r\n\t\t\teventRepository.save(new Event(\"Boxercise\", \r\n\t\t\t\t5,\r\n\t\t\t\t\"7pm\", \"8pm\"));\r\n\t\t};\t\t\r\n\t}\r\n```\r\nIf we relaunch the application now, and use http GET on http://localhost:8080/timetable we should see something like this:\r\n```\r\n[\r\n  {\r\n    \"id\": 1,\r\n    \"title\": \"Yoga\",\r\n    \"day\": 4,\r\n    \"startTime\": \"8pm\",\r\n    \"endTime\": \"9pm\"\r\n  },\r\n  {\r\n    \"id\": 2,\r\n    \"title\": \"Boxercise\",\r\n    \"day\": 5,\r\n    \"startTime\": \"7pm\",\r\n    \"endTime\": \"8pm\"\r\n  }\r\n]\r\n```\r\n###Step 4: Adding more methods\r\nOn to adding the remainder of the API\r\n\r\nNow we can add a method to implement GET for an individual Event. The id of the event is used as part of the URL (this is the path variable).\r\n```java\r\n    @RequestMapping(value=\"/event/{id}\", method=RequestMethod.GET) \r\n    public @ResponseBody Event getEventById(@PathVariable Long id){ \r\n        Event result = eventRepo.findOne(id); \r\n        if (result == null){ \r\n            throw new EventNotFoundException(id); \r\n        } \r\n        return result; \r\n    }\r\n```\r\nIf it can't find the event in the URL, it will throw an exception, this is annotated with `HttpStatus.NOT_FOUND` (404), which Spring will return for us if this exception is thrown\r\n```java\r\n@ResponseStatus(HttpStatus.NOT_FOUND) \r\nclass EventNotFoundException extends RuntimeException { \r\n    private static final long serialVersionUID = -9174199038443186877L; \r\n\r\n    public EventNotFoundException(Long eventId){ \r\n        super(\"could not find event '\" + eventId + \"'.\"); \r\n    } \r\n}\r\n```\r\nNow if we use GET on http://localhost:8080/timetable/event/1 should give us back the yoga class, http://localhost:8080/timetable/event/2 will give the boxercise class\r\n\r\nNext, the POST method can add a new class to the repository. We generate the id automatically, and return the path to the generated event in the http header for the response. This path can be used as the URL for a subsequent request e.g. GET, DELETE\r\n\r\nI'm using POST rather than PUT to implement the create, because I don't know the full URL for the new object (because the id is auto-generated). If the client were generating the id, then the PUT method might be more appropriate to use here\r\n```java\r\n    @RequestMapping(value=\"/event\", method=RequestMethod.POST) \r\n    public ResponseEntity<?> addEvent(@RequestBody Event evt){ \r\n        Event result = eventRepo.save(evt); \r\n        HttpHeaders httpHeaders = new HttpHeaders(); \r\n        httpHeaders.setLocation(ServletUriComponentsBuilder \r\n                .fromCurrentRequest().path(\"/{id}\") \r\n                .buildAndExpand(result.getId()).toUri()); \r\n        return new ResponseEntity<>(result,httpHeaders, HttpStatus.CREATED); \r\n    }\r\n```\r\nFinally, the DELETE method will remove an event\r\n```java\r\n    @RequestMapping(value=\"/event/{id}\", method=RequestMethod.DELETE) \r\n    public void deleteEvent(@PathVariable Long id){ \r\n        eventRepo.delete(id); \r\n    }\r\n```\r\nNow we have all these interfaces implemented, we can test them manually using a tool like Postman, Chrome REST Console, or cURL. This is what the POST call looks like in Postman:\r\n![](./screenshots/postman.png)\r\n\r\n###Step 5: Automated testing\r\nManual testing is something, but it would be good to get some automated tests.\r\n\r\nSpring Boot bundles some unit testing libraries automatically. When we created the project we automatically got a `src/test/java` folder, with a `TimetableApplicationTests` in it.\r\n\r\nIn the same folder, we can create a new class `TimetableControllerTest` to test our rest controller\r\n```java\r\npackage timetable; \r\n... \r\n\r\n@RunWith(SpringJUnit4ClassRunner.class) \r\n@SpringApplicationConfiguration(classes = TimetableApplication.class) \r\n@WebAppConfiguration \r\npublic class TimetableControllerTest { \r\n...\r\n    private MockMvc mockMvc; \r\n```   \r\nWe've told JUnit to user the SpringJUnit4ClassRunner to run the tests so it will be expecting to set up a Spring framework context\r\n\r\n`@SpringApplicationConfiguration` tells the framework where to find its configuration\r\n\r\nThe `@WebAppConfiguration` and `MockMvc` mean we won't be using the full tomcat server for these tests\r\n\r\n```java\r\n    @Autowired \r\n    private WebApplicationContext webApplicationContext; \r\n     \r\n    @Autowired \r\n    private EventRepository eventRepo; \r\n     \r\n    @Before  \r\n    public void setup() throws Exception { \r\n        this.mockMvc = webAppContextSetup(webApplicationContext).build(); \r\n        this.eventRepo.deleteAllInBatch(); \r\n    } \r\n```    \r\nBefore each test we make sure we have a clean set up with our `mockMvc` and also ensure that the in memory database is cleared down so it won't matter what order the tests are run in\r\n\r\nThe simplest thing to test is to check for the 404 not found response for an unknown event:\r\n\r\n```java\r\n    @Test \r\n    public void testEventNotFound() throws Exception { \r\n        mockMvc.perform(get(\"/timetable/event/5\")) \r\n                .andExpect(status().isNotFound()); \r\n    } \r\n```    \r\nThis test checks for the GET on timetable/event/1 - making sure that we have an object in the database to be at that URL.\r\n\r\nThe expectations from the `mockMvc` show we're expecting to get back JSON from the API, test the status from the header, and test the body of the response with the `jsonPath` matcher.\r\n\r\n```java\r\n   private MediaType contentType = new MediaType(MediaType.APPLICATION_JSON.getType(), \r\n            MediaType.APPLICATION_JSON.getSubtype(), \r\n            Charset.forName(\"utf8\")); \r\n     \r\n\t@Test\r\n\tpublic void readSingleEvent() throws Exception {\r\n\t\tEvent evt = this.eventRepo.save(new Event(\"Yoga\",\r\n\t\t\t\t4, \"8pm\", \"9.30pm\"));\r\n\t\tmockMvc.perform(get(\"/timetable/event/\" + evt.getId()))\r\n\t\t\t\t.andExpect(status().isOk())\r\n\t\t\t\t.andExpect(content().contentType(contentType))\r\n\t\t\t\t.andExpect(jsonPath(\"$.id\", is(evt.getId().intValue())))\r\n\t\t\t\t.andExpect(jsonPath(\"$.title\", is(\"Yoga\")))\r\n\t\t\t\t.andExpect(jsonPath(\"$.day\", is(4)))\r\n                .andExpect(jsonPath(\"$.startTime\", is(\"8pm\")))\r\n                .andExpect(jsonPath(\"$.endTime\", is(\"9.30pm\")));\r\n\t}\r\n```    \r\nThe test for GET /timetable/ is very similar, but it's expecting a collection back in the body- we can use matchers to test that too\r\n\r\n```java\r\n\t@Test\r\n\tpublic void readEvents() throws Exception {\r\n\t\tEvent evt1 = this.eventRepo.save( new Event(\"Yoga\", \r\n\t\t\t\t5, \"7pm\", \"8pm\"));\t\t\t\r\n\t\tEvent evt2 = this.eventRepo.save(new Event(\"Boxercise\", \r\n\t\t\t\t6, \"10am\", \"11am\"));\r\n\t\t\r\n\t\tmockMvc.perform(get(\"/timetable\"))\r\n\t\t\t\t.andExpect(status().isOk())\r\n\t\t\t\t.andExpect(content().contentType(contentType))\r\n\t\t\t\t.andExpect(jsonPath(\"$\", hasSize(2)))\r\n\t\t\t\t.andExpect(jsonPath(\"$[0].id\", is(evt1.getId().intValue())))\r\n\t\t\t\t.andExpect(jsonPath(\"$[0].title\", is(\"Yoga\")))\r\n\t\t\t    .andExpect(jsonPath(\"$[0].day\", is(5)))\r\n                .andExpect(jsonPath(\"$[0].startTime\", is(\"7pm\")))\r\n                .andExpect(jsonPath(\"$[0].endTime\", is(\"8pm\")))\r\n\t\t\t\t.andExpect(jsonPath(\"$[1].id\", is(evt2.getId().intValue())))\r\n\t\t\t\t.andExpect(jsonPath(\"$[1].title\", is(\"Boxercise\")))\r\n\t\t\t\t.andExpect(jsonPath(\"$[1].day\", is(6)))\r\n                .andExpect(jsonPath(\"$[1].startTime\", is(\"10am\")))\r\n                .andExpect(jsonPath(\"$[1].endTime\", is(\"11am\")));\r\n\t}\r\n```    \r\nTo test POST on /timetable/event/ we need a helper function to give us a JSON string to send. We also need to retrieve from the response from POST the path where the new Event was created, then we can use this as input to a GET request to check that it was saved as we expect\r\n\r\n```java\r\n\t@Test\r\n\tpublic void createEvent() throws Exception {\r\n\t\tString eventJson = json( new Event(\r\n\t\t\t\t\"lane swimming\", 3, \"4pm\", \"9pm\"));\r\n\t\t\r\n\t\tMvcResult result = this.mockMvc.perform(post(\"/timetable/event\")\r\n\t\t\t\t.contentType(contentType)\r\n\t\t\t\t.content(eventJson))\r\n\t\t\t\t.andExpect(status().isCreated())\r\n\t\t\t\t.andExpect(content().contentType(contentType))\r\n                .andExpect(jsonPath(\"$.title\", is(\"lane swimming\")))\r\n                .andExpect(jsonPath(\"$.day\", is(3)))\r\n                .andExpect(jsonPath(\"$.startTime\", is(\"4pm\")))\r\n                .andExpect(jsonPath(\"$.endTime\", is(\"9pm\")))\r\n                .andReturn();\r\n\t\tString createdPath = result.getResponse().getHeader(\"Location\");\r\n\t\tthis.mockMvc.perform(get(createdPath))\r\n\t\t\t.andExpect(status().isOk())\r\n\t\t\t.andExpect(jsonPath(\"$.title\", is(\"lane swimming\")));\r\n\t}\r\n     \r\n    protected String json(Object o) throws IOException { \r\n        ObjectMapper mapper = new ObjectMapper(); \r\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); \r\n        return mapper.writeValueAsString(o); \r\n    } \r\n```\r\nFinally, the test for DELETE is similar- POST to create an Event, and make sure we know the URL for it, a quick GET to be sure it was there, then after DELETE check that we get 404 on a second GET request.\r\n\r\n```java\r\n\t@Test\r\n\tpublic void testDeleteEvent() throws Exception {\r\n\t\tString eventJson = json( new Event(\r\n\t\t\t\t\"Pilates\", 7, \"9am\", \"11am\"));\r\n\t\t\t\t\r\n\t\tMvcResult result = this.mockMvc.perform(post(\"/timetable/event\")\r\n\t\t\t\t.contentType(contentType)\r\n\t\t\t\t.content(eventJson))\r\n\t\t\t\t.andExpect(status().isCreated())\r\n\t\t\t\t.andExpect(content().contentType(contentType))\r\n                .andExpect(jsonPath(\"$.title\", is(\"Pilates\")))\r\n                .andReturn();\r\n\t\tString createdLocation = result.getResponse().getHeader(\"Location\");\r\n\t\tthis.mockMvc.perform(get(createdLocation))\r\n\t\t\t.andExpect(status().isOk())\r\n\t\t\t.andExpect(jsonPath(\"$.title\", is(\"Pilates\")))\r\n\t\t\t.andExpect(jsonPath(\"$.day\", is(7)))\r\n            .andExpect(jsonPath(\"$.startTime\", is(\"9am\")))\r\n            .andExpect(jsonPath(\"$.endTime\", is(\"11am\")));\r\n\t\t\r\n\t\tthis.mockMvc.perform(delete(createdLocation))\r\n\t\t.andExpect(status().isOk());\r\n\t\t\r\n\t\tthis.mockMvc.perform(get(createdLocation))\r\n\t\t.andExpect(status().isNotFound());\r\n\t}\r\n```\r\nWe also need an additional dependency in the maven `pom.xml`. Spring included `spring-boot-starter-test` automatically, but the `jsonPath` matcher requires an extra artifact:\r\n```xml\r\n  <dependency> \r\n    <groupId>com.jayway.jsonpath</groupId> \r\n    <artifactId>json-path-assert</artifactId> \r\n    <version>0.8.1</version> \r\n    <scope>test</scope> \r\n  </dependency>\r\n``` \r\n\r\n###Step 6: Adding a Java REST client\r\nNext we'll add a client for this API.\r\n\r\nCreate a new project for this, again using Spring Boot. This time we'll use the web and thymeleaf options only.\r\n\r\nThe project is `timetable_mvc_client` and its pom.xml looks like this:\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> \r\n  <modelVersion>4.0.0</modelVersion> \r\n\r\n  <groupId>org.me</groupId> \r\n  <artifactId>timetable_mvc_client</artifactId> \r\n  <version>0.0.1-SNAPSHOT</version> \r\n  <packaging>jar</packaging> \r\n\r\n  <name>timetable_mvc_client</name> \r\n  <description>Spring boot mvc client for timetable rest service</description> \r\n\r\n  <parent> \r\n    <groupId>org.springframework.boot</groupId> \r\n    <artifactId>spring-boot-starter-parent</artifactId> \r\n    <version>1.2.3.RELEASE</version> \r\n    <relativePath/> <!-- lookup parent from repository --> \r\n  </parent> \r\n\r\n  <properties> \r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> \r\n    <start-class>timetable_mvc_client.TimetableMvcClientApplication</start-class> \r\n    <java.version>1.8</java.version> \r\n  </properties> \r\n\r\n  <dependencies> \r\n    <dependency> \r\n      <groupId>org.springframework.boot</groupId> \r\n      <artifactId>spring-boot-starter-thymeleaf</artifactId> \r\n    </dependency> \r\n    <dependency> \r\n      <groupId>org.springframework.boot</groupId> \r\n      <artifactId>spring-boot-starter-web</artifactId> \r\n    </dependency> \r\n    <dependency> \r\n      <groupId>org.springframework.boot</groupId> \r\n      <artifactId>spring-boot-starter-test</artifactId> \r\n      <scope>test</scope> \r\n    </dependency> \r\n  </dependencies> \r\n   \r\n  <build> \r\n    <plugins> \r\n      <plugin> \r\n        <groupId>org.springframework.boot</groupId> \r\n        <artifactId>spring-boot-maven-plugin</artifactId> \r\n      </plugin> \r\n    </plugins> \r\n  </build> \r\n\r\n</project>\r\n```\r\nSpring Boot should have generated us a class with a main method as a starter:\r\n```\r\npackage timetable_mvc_client; \r\n\r\nimport org.springframework.boot.SpringApplication; \r\nimport org.springframework.boot.autoconfigure.SpringBootApplication; \r\n\r\n@SpringBootApplication \r\npublic class TimetableMvcClientApplication { \r\n\r\n  public static void main(String[] args) { \r\n    SpringApplication.run(TimetableMvcClientApplication.class, args); \r\n  } \r\n} \r\n```\r\nWe need a controller. I've added a new package timetable_mvc_client.controllers to hold this\r\n```\r\npackage timetable_mvc_client.controllers; \r\n\r\nimport java.util.Arrays; \r\nimport org.springframework.stereotype.Controller; \r\nimport org.springframework.ui.Model; \r\nimport org.springframework.web.bind.annotation.RequestMapping; \r\nimport org.springframework.web.client.RestTemplate; \r\n\r\nimport timetable_mvc_client.model.Timetable; \r\nimport timetable_mvc_client.model.TimetableClass; \r\n\r\n@Controller \r\npublic class TimetableController { \r\n\r\n @RequestMapping(\"/timetable\") \r\n public String showFullTimetable(Model model){ \r\n  model.addAttribute(\"timetable\", this.getFullTimetable()); \r\n  return \"full_timetable\"; \r\n } \r\n\r\n private Timetable getFullTimetable() { \r\n  RestTemplate restTemplate = new RestTemplate(); \r\n  TimetableClass[] classes = restTemplate.getForObject( \"http://localhost:8080/timetable\", TimetableClass[].class); \r\n  Timetable fullTimetable = new Timetable(); \r\n  fullTimetable.setClasses(Arrays.asList(classes)); \r\n  return fullTimetable; \r\n } \r\n} \r\n```\r\n```\r\npackage timetable_mvc_client.controllers; \r\n\r\nimport org.springframework.http.ResponseEntity; \r\nimport org.springframework.stereotype.Controller; \r\nimport org.springframework.ui.Model; \r\nimport org.springframework.web.bind.annotation.RequestMapping; \r\nimport org.springframework.web.bind.annotation.RequestMethod; \r\nimport org.springframework.web.client.RestTemplate; \r\n\r\nimport timetable_mvc_client.model.TimetableClass; \r\n\r\n@Controller \r\npublic class ClassController { \r\n @RequestMapping(\"/class\") \r\n public String showCreateClassForm(Model model){ \r\n  return \"new_class\"; \r\n } \r\n  \r\n @RequestMapping(value=\"/class\", method=RequestMethod.POST) \r\n public String createNewClass(TimetableClass newClass){ \r\n  RestTemplate restTemplate = new RestTemplate(); \r\n  ResponseEntity<TimetableClass> response = restTemplate.postForEntity(\"http://localhost:8080/timetable/event\", newClass, TimetableClass.class); \r\n  return \"redirect:timetable\"; \r\n } \r\n}\r\n```\r\nA couple of classes for the model (data)\r\n\r\n```\r\npackage timetable_mvc_client.model; \r\n\r\nimport java.util.List; \r\n\r\npublic class Timetable { \r\n private List<TimetableClass> classes; \r\n\r\n public List<TimetableClass> getClasses() { \r\n  return classes; \r\n } \r\n\r\n public void setClasses(List<TimetableClass> classes) { \r\n  this.classes = classes; \r\n } \r\n} \r\n```\r\n```\r\npackage timetable_mvc_client.model; \r\n\r\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties; \r\n\r\n@JsonIgnoreProperties(ignoreUnknown = true) \r\npublic class TimetableClass { \r\n private String title; \r\n private Integer day; \r\n private String startTime; \r\n private String endTime; \r\n  \r\n public String getTitle() { \r\n  return title; \r\n } \r\n public void setTitle(String title) { \r\n  this.title = title; \r\n } \r\n public Integer getDay() { \r\n  return day; \r\n } \r\n public void setDay(Integer day) { \r\n  this.day = day; \r\n } \r\n public String getStartTime() { \r\n  return startTime; \r\n } \r\n public void setStartTime(String startTime) { \r\n  this.startTime = startTime; \r\n } \r\n public String getEndTime() { \r\n  return endTime; \r\n } \r\n public void setEndTime(String endTime) { \r\n  this.endTime = endTime; \r\n } \r\n} \r\n```\r\nAnd a view...in the `src/main/resources/templates` folder create `full_timetable.html`\r\n```\r\n<!DOCTYPE html> \r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" \r\n   xmlns:th=\"http://www.thymeleaf.org\"> \r\n\r\n <head> \r\n  <title>Gym Timetable</title> \r\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /> \r\n </head> \r\n <body> \r\n <h1 th:text=\"#{title.timetableevents}\">Timetable of Events</h1> \r\n  <table> \r\n   <tr> \r\n    <th th:text=\"#{timetable.header.class}\">CLASS</th> \r\n    <th th:text=\"#{timetable.header.day}\">DAY</th> \r\n    <th th:text=\"#{timetable.header.startTime}\">START TIME</th> \r\n    <th th:text=\"#{timetable.header.endTime}\">END TIME</th> \r\n   </tr> \r\n   <tr th:each=\"gymClass : ${timetable.classes}\"> \r\n    <td th:text=\"${gymClass.title}\">A class</td> \r\n    <td th:text=\"${gymClass.day} != null ? #{day__${gymClass.day}__} : ''\">day</td> \r\n    <td th:text=\"${gymClass.startTime}\">start</td> \r\n    <td th:text=\"${gymClass.endTime}\">end</td> \r\n   </tr> \r\n  </table> \r\n  <a href=\"/createClass\" th:href=\"@{/class}\" th:text=\"#{link.createNewClass}\">create</a> \r\n </body> \r\n```\r\n```\r\n</html> <!DOCTYPE html> \r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" \r\n   xmlns:th=\"http://www.thymeleaf.org\"> \r\n\r\n <head> \r\n  <title>New Class</title> \r\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /> \r\n </head> \r\n <body> \r\n <h1 th:text=\"#{title.createNewClass}\">New Class</h1> \r\n  <form id=\"new-class-form\" role=\"form\" th:action=\"@{/class}\" method=\"post\" th:object=\"${TimetableClass}\"> \r\n   <label for=\"title\" th:text=\"#{newclass.title}\">title</label> \r\n   <input type=\"text\" id=\"title\" name=\"title\" value=\"\"/> \r\n   <label for=\"day\" th:text=\"#{newclass.day}\">day</label> \r\n   <select name=\"day\"> \r\n    <option value=\"1\" th:text=\"#{day1}\">Mon</option> \r\n    <option value=\"2\" th:text=\"#{day2}\">Tue</option> \r\n    <option value=\"3\" th:text=\"#{day3}\">Wed</option> \r\n    <option value=\"4\" th:text=\"#{day4}\">Thu</option> \r\n    <option value=\"5\" th:text=\"#{day5}\">Fri</option> \r\n    <option value=\"6\" th:text=\"#{day6}\">Sat</option> \r\n    <option value=\"7\" th:text=\"#{day7}\">Sun</option> \r\n   </select> \r\n   <label for=\"startTime\" th:text=\"#{newclass.startTime}\">startTime</label> \r\n   <input type=\"text\" id=\"startTime\" name=\"startTime\" value=\"\"/> \r\n   <label for=\"endTime\" th:text=\"#{newclass.endTime}\">startTime</label> \r\n   <input type=\"text\" id=\"endTime\" name=\"endTime\" value=\"\"/> \r\n   <div> \r\n     <button type=\"submit\">Save</button> \r\n   </div> \r\n  </form> \r\n  <a href=\"/timetable\" th:href=\"@{/timetable}\" th:text=\"#{link.fullTimetable}\">back</a> \r\n </body> \r\n</html>\r\n```\r\nThe labels and static text come from `messages.properties` in `src/main/resources`\r\n\r\n```\r\ntitle.timetableevents=What's on \r\ntimetable.header.class=Class \r\ntimetable.header.day=Day \r\ntimetable.header.startTime=Start Time \r\ntimetable.header.endTime=End Time \r\nlink.createNewClass=Create New Class \r\ntitle.createNewClass=New Class \r\nlink.fullTimetable=Show Full Timetable \r\nnewclass.title=Class title: \r\nnewclass.day=Day: \r\nnewclass.startTime=Start: \r\nnewclass.endTime=End: \r\nday1=Monday \r\nday2=Tuesday \r\nday3=Wednesday \r\nday4=Thursday \r\nday5=Friday \r\nday6=Saturday \r\nday7=Sunday\r\n```\r\nFinally, before running up the application, if it's going to run on the same host machine as the timetable rest server, we'll need to make sure that the tomcat server inside the mvc client starts on a different port. This can be set as an argument at runtime, or we can set it up in application.properties (also in `src/main/resources`)\r\n```\r\nserver.port = 9080\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}